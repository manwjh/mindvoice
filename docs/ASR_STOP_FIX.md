# ASR 停止锁死问题修复

## 问题描述

在某些异常情况下，系统在停止ASR时会出现锁死现象：
- ASR状态卡在 `stopping` 状态无法恢复
- 无法切换到其他应用
- 无法再次启动ASR
- 后端日志显示多次重复调用停止API
- 等待ASR最终结果超时（6秒 + 2秒额外等待）

## 根本原因

从日志分析发现以下问题：

1. **超时等待过长**
   - 后端等待ASR最终结果的超时时间为6秒
   - 超时后还会额外等待2秒尝试获取回调结果
   - 总计可能等待8秒以上

2. **重复调用停止API**
   - 前端没有防止重复点击的机制
   - 用户在等待过程中可能多次点击停止按钮
   - 导致后端收到多次停止请求

3. **状态管理不完善**
   - 异常情况下状态可能未正确重置为 `idle`
   - 没有超时保护机制
   - 前端状态与后端状态可能不同步

4. **ASR WebSocket关闭延迟**
   - 等待最终结果时间过长（5秒 + 1.5秒）
   - 导致整体停止流程耗时过长

## 修复方案

### 1. 优化超时时间（后端）

**文件**: `src/services/voice_service.py`

- ✅ 将等待ASR最终结果的超时时间从 **6秒** 缩短到 **3秒**
- ✅ 移除超时后的额外2秒等待逻辑
- ✅ 超时后直接使用当前文本作为最终结果
- ✅ 不再将超时视为错误（用户可能没有说话）

**文件**: `src/providers/asr/volcano.py`

- ✅ 将等待最终结果的超时时间从 **5秒** 缩短到 **2秒**
- ✅ 移除额外的1.5秒等待时间（1.0秒 + 0.5秒）
- ✅ 只保留0.5秒的短暂等待，确保最后的响应被处理

### 2. 防止重复调用（前端）

**文件**: `electron-app/src/App.tsx`

- ✅ 在 `stopAsr()` 函数开始时检查状态
- ✅ 如果已经在 `stopping` 状态，直接返回，忽略重复调用
- ✅ 立即更新状态为 `stopping`，防止重复点击
- ✅ 添加日志输出，便于调试

```typescript
// 防止重复调用：如果已经在停止中，直接返回
if (asrState === 'stopping') {
  console.log('[App] ASR已在停止中，忽略重复调用');
  return;
}

// 立即更新状态为stopping，防止重复点击
setAsrState('stopping');
```

### 3. 添加超时保护（前端）

**文件**: `electron-app/src/App.tsx`

- ✅ 设置10秒超时定时器
- ✅ 如果10秒后状态还是 `stopping`，强制重置为 `idle`
- ✅ 显示错误提示，告知用户状态已被强制重置
- ✅ 正常完成或发生错误时清除定时器

```typescript
// 设置超时保护：如果10秒后状态还是stopping，强制重置为idle
const timeoutId = setTimeout(() => {
  console.warn('[App] ASR停止超时(10秒)，强制重置状态为idle');
  setAsrState('idle');
  setError('ASR停止超时，已强制重置状态。如果问题持续，请重启应用。');
}, 10000);

try {
  // ... API调用 ...
  clearTimeout(timeoutId);
} catch (e) {
  clearTimeout(timeoutId);
  // ... 错误处理 ...
}
```

### 4. 改进状态管理（后端）

**文件**: `src/services/voice_service.py`

- ✅ 使用 `try-except-finally` 结构确保状态一定会被重置
- ✅ 在 `finally` 块中无论如何都将状态重置为 `IDLE`
- ✅ 捕获所有异常，防止异常导致状态未重置
- ✅ 确保 `_streaming_active` 标志被正确重置

```python
try:
    # ... 停止录音逻辑 ...
    return final_text
except Exception as e:
    logger.error(f"[语音服务] 停止录音过程发生异常: {e}", exc_info=True)
    self._streaming_active = False
    return None
finally:
    # 无论如何都要确保状态被重置为IDLE
    self._notify_state_change(RecordingState.IDLE)
    logger.info("[语音服务] 录音已停止，状态: IDLE")
```

## 修复效果

### 时间优化

| 阶段 | 修复前 | 修复后 | 改善 |
|------|--------|--------|------|
| 后端等待ASR结果 | 6秒 + 2秒 = 8秒 | 3秒 | -62.5% |
| ASR WebSocket关闭 | 5秒 + 1.5秒 = 6.5秒 | 2秒 + 0.5秒 = 2.5秒 | -61.5% |
| 前端超时保护 | 无 | 10秒 | 新增 |
| **总体停止时间** | **可能超过14秒** | **最多5.5秒** | **-60.7%** |

### 可靠性提升

- ✅ **防止重复调用**: 前端检查状态，避免重复点击
- ✅ **超时保护**: 10秒后强制重置状态，确保不会永久锁死
- ✅ **状态保证**: 使用 `finally` 块确保状态一定会被重置
- ✅ **异常处理**: 捕获所有异常，防止未预期的错误

### 用户体验改善

- ⚡ **响应更快**: 停止ASR的时间从14秒缩短到5.5秒以内
- 🛡️ **更可靠**: 即使出现异常，10秒后也会自动恢复
- 🚫 **防误操作**: 重复点击停止按钮不会导致问题
- 📊 **更清晰**: 超时时会显示明确的错误提示

## 测试建议

### 正常场景测试

1. ✅ 启动ASR → 说话 → 停止ASR → 检查状态是否正确恢复为 `idle`
2. ✅ 启动ASR → 不说话 → 停止ASR → 检查是否正常处理空结果
3. ✅ 启动ASR → 说话 → 停止ASR → 立即再次启动 → 检查是否正常工作

### 异常场景测试

1. ✅ 启动ASR → 停止ASR时快速多次点击停止按钮 → 检查是否只调用一次API
2. ✅ 启动ASR → 断开网络 → 停止ASR → 检查是否在10秒内恢复状态
3. ✅ 启动ASR → 后端服务异常 → 停止ASR → 检查前端是否能自动恢复

### 压力测试

1. ✅ 连续多次快速启动和停止ASR
2. ✅ 在不同应用间快速切换
3. ✅ 长时间运行后测试停止功能

## 日志监控

修复后，正常的停止流程日志应该类似：

```
2025-12-31 16:57:00 - [语音服务] 停止录音...
2025-12-31 16:57:00 - [语音服务] 状态: STOPPING
2025-12-31 16:57:00 - [语音服务] 停止录音器...
2025-12-31 16:57:00 - [语音服务] 已清除音频数据块回调
2025-12-31 16:57:00 - [语音服务] 停止流式识别并关闭ASR WebSocket连接...
2025-12-31 16:57:00 - [ASR] 开始停止流式识别...
2025-12-31 16:57:02 - [ASR] 收到最终结果信号（或超时）
2025-12-31 16:57:02 - [ASR] 流式识别完成，最终结果: 'xxx'
2025-12-31 16:57:02 - [ASR] 关闭WebSocket连接...
2025-12-31 16:57:02 - [ASR] WebSocket连接已关闭
2025-12-31 16:57:02 - [语音服务] ASR最终结果: 'xxx'
2025-12-31 16:57:02 - [语音服务] 流式识别已停止，WebSocket连接已关闭
2025-12-31 16:57:02 - [语音服务] 录音已停止，状态: IDLE
```

**总耗时**: 约2-3秒（相比修复前的8-14秒大幅改善）

## 注意事项

1. **不要降低超时时间过多**: 3秒和2秒是经过平衡的值，太短可能导致正常情况下也超时
2. **前端10秒超时是最后防线**: 正常情况下应该在5秒内完成，10秒超时只是保护机制
3. **监控日志**: 如果频繁出现超时，可能是网络或ASR服务的问题，需要进一步排查
4. **用户提示**: 如果触发10秒超时保护，建议用户检查网络连接或重启应用

## 相关文件

- `src/services/voice_service.py` - 语音服务主逻辑
- `src/providers/asr/volcano.py` - 火山引擎ASR提供商
- `electron-app/src/App.tsx` - 前端主应用逻辑

---

**修复日期**: 2025-12-31  
**修复版本**: 1.1.0+  
**修复人员**: 深圳王哥 & AI

